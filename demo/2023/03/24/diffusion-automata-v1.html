<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <title>Diffusion Automata v1</title><!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v3.9.3" />
<meta property="og:title" content="Diffusion Automata v1" />
<meta name="author" content="Joel Schutz" />
<meta property="og:locale" content="pt_br" />
<meta name="description" content="A ideia desse Automata é simular a dispersão de um liquido em um meio solido permeável, como solo, areia, etc. Ele foi criado como protótipo de um sistema de dispersão de água subterrânea para meu jogo." />
<meta property="og:description" content="A ideia desse Automata é simular a dispersão de um liquido em um meio solido permeável, como solo, areia, etc. Ele foi criado como protótipo de um sistema de dispersão de água subterrânea para meu jogo." />
<link rel="canonical" href="https://github.com/devlog/demo/2023/03/24/diffusion-automata-v1.html" />
<meta property="og:url" content="https://github.com/devlog/demo/2023/03/24/diffusion-automata-v1.html" />
<meta property="og:site_name" content="Joel’s Dev Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-03-24T01:04:38+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Diffusion Automata v1" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Joel Schutz"},"dateModified":"2023-03-24T01:04:38+00:00","datePublished":"2023-03-24T01:04:38+00:00","description":"A ideia desse Automata é simular a dispersão de um liquido em um meio solido permeável, como solo, areia, etc. Ele foi criado como protótipo de um sistema de dispersão de água subterrânea para meu jogo.","headline":"Diffusion Automata v1","mainEntityOfPage":{"@type":"WebPage","@id":"https://github.com/devlog/demo/2023/03/24/diffusion-automata-v1.html"},"url":"https://github.com/devlog/demo/2023/03/24/diffusion-automata-v1.html"}</script>
<!-- End Jekyll SEO tag -->
<link type="application/atom+xml" rel="alternate" href="https://github.com/devlog/feed.xml" title="Joel's Dev Blog" /><link rel="shortcut icon" type="image/x-icon" href="/devlog/favicon.ico" />
  <link rel="stylesheet" href="/devlog/assets/css/main.css" />
  <script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
</head><body a="dark">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/devlog/">../</a><article>
  <p class="post-meta">
    <time datetime="2023-03-24 01:04:38 +0000">Mar-24-2023</time>
  </p><p class="languages">
    
        
    pt-br
        
    
        
            
    <a href="/devlog/en/demo/2023/03/24/diffusion-automata-v1.html">en</a>
            
        
    
    </p><p>
    <iframe frameborder="0" scrolling="no" src="/devlog/assets/wasm/Automata/automata.html" srcdoc="
    <!DOCTYPE html>
      <script src=&quot;/devlog/assets/wasm/wasm_exec.js&quot;></script>
      <script>
      // Polyfill
      if (!WebAssembly.instantiateStreaming) {
          WebAssembly.instantiateStreaming = async (resp, importObject) => {
              const source = await (await resp).arrayBuffer();
              return await WebAssembly.instantiate(source, importObject);
          };
      }
      
      const go = new Go();
      WebAssembly.instantiateStreaming(fetch(&quot;/devlog/assets/wasm/Automata/automata.v1.wasm&quot;), go.importObject).then(result => {
          go.run(result.instance);
      });
      </script>" width="100%" height="480"></iframe>
  </p><h1>Diffusion Automata v1</h1>

  <p>A ideia desse Automata é simular a dispersão de um
liquido em um meio solido permeável, como solo, areia, etc.
Ele foi criado como protótipo de um sistema de dispersão de
água subterrânea para meu jogo.</p>

<p>Como vai perceber, não existe muita complexidade nesse código,
essa é a magica desse tipo de algoritmo, com regras simples é
possível construir comportamentos complexos. Aqui, simulamos
a interação entre líquidos e sólidos no tempo e espaço usando apenas
aritmética básica.</p>

<p>Nosso espaço será representado como um 2d array de vetores, mas
no nosso caso eles servem apenas como uma forma conveniente de
agrupar nossos dois valores relevantes:</p>

<ul>
  <li>Umidade
    <ul>
      <li>A quantidade de liquido contido naquela célula</li>
    </ul>
  </li>
  <li>Impermeabilidade
    <ul>
      <li>A resistência que o material daquela célula apresenta ao movimento de liquido</li>
    </ul>
  </li>
</ul>

<p>Os campos <code class="language-plaintext highlighter-rouge">Rocks</code> e <code class="language-plaintext highlighter-rouge">Rain</code> servem para demonstrar, respectivamente,
células totalmente impermeáveis e células que sao fontes de umidade.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">HumidityBoard</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">values</span>      <span class="p">[][]</span><span class="n">mgl32</span><span class="o">.</span><span class="n">Vec2</span> <span class="c">// [humidity, impermeability]</span>
	<span class="n">Rocks</span><span class="p">,</span> <span class="n">Rain</span> <span class="p">[][]</span><span class="kt">bool</span>
	<span class="n">hvrX</span><span class="p">,</span> <span class="n">hvrY</span>  <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A lógica para determinar a umidade de uma célula é bastante simples,
entendendo que ao longo do tempo o liquido tende a se espalhar uniformemente
pelo espaço, assumimos que o nosso valor de umidade da célula é a média aritmética
entre o seu valor atual e a das suas vizinhas. Por simplicidade assumimos apenas
4 vizinhos conforme esse diagrama onde <code class="language-plaintext highlighter-rouge">v0</code> é a célula atual:</p>

<table>
  <tbody>
    <tr>
      <td> </td>
      <td>v3</td>
      <td> </td>
    </tr>
    <tr>
      <td>v1</td>
      <td>v0</td>
      <td>v2</td>
    </tr>
    <tr>
      <td> </td>
      <td>v4</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<p>Para considerar a permeabilidade, utilizamos uma média ponderada onde
o peso de cada termo é definido pelo valor de impermeabilidade daquela célula.
O detalhe é que consideramos o reciproco(1/valor) como peso das células vizinhas,
dessa forma conseguimos o efeito de que uma célula altamente impermeável tende
a não perder umidade ao mesmo tempo que resiste à absorção de mais liquido. Além
disso, verificamos se a célula excede o nosso limite de 1024 e ajustamos então o valor para esse limite.</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">ba</span> <span class="o">*</span><span class="n">HumidityBoard</span><span class="p">)</span> <span class="n">Update</span><span class="p">()</span> <span class="kt">error</span> <span class="p">{</span>
	<span class="c">// Armazenamos o estado inicial do espaço para servir de referencia</span>
	<span class="n">m0</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([][]</span><span class="n">mgl32</span><span class="o">.</span><span class="n">Vec2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ba</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
	<span class="nb">copy</span><span class="p">(</span><span class="n">m0</span><span class="p">,</span> <span class="n">ba</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">row</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">ba</span><span class="o">.</span><span class="n">values</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">v0</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">row</span> <span class="p">{</span>
			<span class="c">// Pulamos o calculo de fontes de umidade e células com alto impermeabilidade</span>
			<span class="k">if</span> <span class="n">ba</span><span class="o">.</span><span class="n">Rain</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">]</span> <span class="o">||</span> <span class="n">v0</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">MaxFloat32</span><span class="o">/</span><span class="m">5</span><span class="p">)</span><span class="o">*</span><span class="m">4</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>

			<span class="c">// Assumimos que as bordas são células secas e impermeáveis</span>
			<span class="n">v1</span> <span class="o">:=</span> <span class="n">mgl32</span><span class="o">.</span><span class="n">Vec2</span><span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">MaxFloat32</span><span class="p">}</span>
			<span class="n">v2</span> <span class="o">:=</span> <span class="n">mgl32</span><span class="o">.</span><span class="n">Vec2</span><span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">MaxFloat32</span><span class="p">}</span>
			<span class="n">v3</span> <span class="o">:=</span> <span class="n">mgl32</span><span class="o">.</span><span class="n">Vec2</span><span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">MaxFloat32</span><span class="p">}</span>
			<span class="n">v4</span> <span class="o">:=</span> <span class="n">mgl32</span><span class="o">.</span><span class="n">Vec2</span><span class="p">{</span><span class="m">0</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">MaxFloat32</span><span class="p">}</span>

			<span class="c">// Verificamos se o vizinho existe e aplicamos os valores corretos</span>
			<span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
				<span class="n">v1</span> <span class="o">=</span> <span class="n">m0</span><span class="p">[</span><span class="n">x</span><span class="o">-</span><span class="m">1</span><span class="p">][</span><span class="n">y</span><span class="p">]</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">m0</span><span class="p">)</span><span class="o">-</span><span class="m">1</span> <span class="p">{</span>
				<span class="n">v2</span> <span class="o">=</span> <span class="n">m0</span><span class="p">[</span><span class="n">x</span><span class="o">+</span><span class="m">1</span><span class="p">][</span><span class="n">y</span><span class="p">]</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
				<span class="n">v3</span> <span class="o">=</span> <span class="n">m0</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="o">-</span><span class="m">1</span><span class="p">]</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">m0</span><span class="p">)</span><span class="o">-</span><span class="m">1</span> <span class="p">{</span>
				<span class="n">v4</span> <span class="o">=</span> <span class="n">m0</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="o">+</span><span class="m">1</span><span class="p">]</span>
			<span class="p">}</span>

			<span class="c">// Calculamos a média aritmética ponderada</span>
			<span class="n">r</span> <span class="o">:=</span> <span class="p">((</span><span class="n">v0</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">v0</span><span class="p">[</span><span class="m">1</span><span class="p">]))</span> <span class="o">+</span> <span class="p">(</span><span class="n">v1</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">v1</span><span class="p">[</span><span class="m">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">v2</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">v2</span><span class="p">[</span><span class="m">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">v3</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">v3</span><span class="p">[</span><span class="m">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">v4</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">v4</span><span class="p">[</span><span class="m">1</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span><span class="n">v0</span><span class="p">[</span><span class="m">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="m">1</span> <span class="o">/</span> <span class="n">v1</span><span class="p">[</span><span class="m">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="m">1</span> <span class="o">/</span> <span class="n">v2</span><span class="p">[</span><span class="m">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="m">1</span> <span class="o">/</span> <span class="n">v3</span><span class="p">[</span><span class="m">1</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="m">1</span> <span class="o">/</span> <span class="n">v4</span><span class="p">[</span><span class="m">1</span><span class="p">]))</span>

			<span class="c">// Limitamos os valores a um máximo de 1024</span>
			<span class="k">if</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="m">1024</span> <span class="p">{</span>
				<span class="n">r</span> <span class="o">=</span> <span class="m">1024</span>
			<span class="p">}</span>

			<span class="c">// Atualizamos espaço com novo valor de umidade</span>
			<span class="n">ba</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="m">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div>

<p>O resultado no fim não é perfeito, há parâmetros que não são levados em consideração como
velocidade e densidade do liquido, mas para o nosso caso já é suficiente. Outra limitação
é quanto a conservação de massa do sistema. Aos poucos o volume total de umidade cai e isso
causa o efeito de umidade desaparecendo espontaneamente, que é fisicamente impossível.</p>

<p>Como dito, esse é um protótipo e limitações como essa não são necessariamente problemas
para aplicação em jogos. Vale lembrar que esse algoritmo foi escrito de forma síncrona,
mas é totalmente possível adapta-lo para operar de forma paralelizada.</p>

</article>
      </div>
    </main><script data-goatcounter="https://joelschutz.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>

<noscript>
  <img src="https://joelschutz.goatcounter.com/count?p=/test-img">
</noscript>
  </body>
</html>